<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#4f46e5">
    <meta name="description" content="Manga Extractor & Merger Tool">
    <title>Manga Tool Ultimate</title>

    <link rel="manifest" href="manifest.json">

    <style>
        :root { --primary: #4f46e5; --bg-color: #f8fafc; --card-bg: #ffffff; --text-main: #1e293b; --text-sub: #64748b; --border: #e2e8f0; --panel-bg: #f1f5f9; --drop-bg: #f8fafc; --drop-border: #cbd5e1; --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05); --modal-bg: rgba(255, 255, 255, 0.98); --danger: #ef4444; --warning-bg: #fff7ed; --warning-text: #c2410c; }
        [data-theme="dark"] { --primary: #6366f1; --bg-color: #0f172a; --card-bg: #1e293b; --text-main: #f1f5f9; --text-sub: #94a3b8; --border: #334155; --panel-bg: #0f172a; --drop-bg: #1e293b; --drop-border: #475569; --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5); --modal-bg: rgba(15, 23, 42, 0.98); --warning-bg: #431407; --warning-text: #fdba74; }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg-color); color: var(--text-main); display: flex; justify-content: center; align-items: start; min-height: 100vh; margin: 0; padding: 20px; padding-bottom: 100px; transition: 0.3s; }

        .container { width: 100%; max-width: 900px; }
        .card { background: var(--card-bg); border-radius: 16px; box-shadow: var(--shadow); padding: 1.5rem; border: 1px solid var(--border); }

        /* Header */
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        h1 { margin: 0; font-size: 1.5rem; font-weight: 800; letter-spacing: -0.5px; }
        .count-badge { font-size: 0.8rem; background: var(--primary); color: white; padding: 4px 10px; border-radius: 20px; margin-left: 10px; display: none;}

        /* Tabs */
        .mode-tabs { display: flex; background: var(--panel-bg); padding: 4px; border-radius: 12px; gap: 4px; border: 1px solid var(--border); margin-bottom: 1.5rem; }
        .mode-tab { flex: 1; border: none; background: transparent; padding: 10px; font-weight: 600; color: var(--text-sub); border-radius: 8px; cursor: pointer; transition: 0.2s; font-size: 0.9rem; }
        .mode-tab.active { background: var(--card-bg); color: var(--primary); box-shadow: 0 2px 8px rgba(0,0,0,0.08); }

        /* Controls */
        .controls-wrapper { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        .control-panel { background: var(--panel-bg); padding: 1rem; border-radius: 12px; border: 1px solid var(--border); }
        .control-label { display: block; font-size: 0.7rem; font-weight: 700; text-transform: uppercase; color: var(--text-sub); margin-bottom: 0.8rem; }

        .range-row { display: flex; align-items: center; gap: 10px; font-size: 0.9rem; font-weight: 600; }
        input[type=range] { flex: 1; accent-color: var(--primary); }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.9rem; font-weight: 500; }
        .switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--drop-border); transition: .3s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(16px); }

        .btn-sm { font-size: 0.75rem; padding: 4px 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--card-bg); cursor: pointer; color: var(--text-main); font-weight: 600; transition:0.2s; }
        .btn-sm:hover { background: var(--primary); color: white; border-color: var(--primary); }

        /* Upload */
        .drop-zone { border: 2px dashed var(--drop-border); border-radius: 12px; padding: 3rem 2rem; text-align: center; cursor: pointer; background: var(--drop-bg); transition: 0.2s; }
        .drop-zone:hover { border-color: var(--primary); background: rgba(79, 70, 229, 0.05); transform: scale(0.99); }

        /* Progress */
        .progress-container { margin-top: 2rem; display: none; }
        .progress-info { display: flex; justify-content: space-between; font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; }
        .progress-track { width: 100%; height: 6px; background: var(--border); border-radius: 10px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.1s linear; }

        /* Gallery / List View */
        .chapter-list { margin-top: 2rem; display: flex; flex-direction: column; gap: 10px; }
        .chapter-item { border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: var(--card-bg); }
        .chapter-head { padding: 12px 15px; display: flex; justify-content: space-between; align-items: center; background: var(--panel-bg); cursor: pointer; user-select: none; font-weight: 600; font-size: 0.9rem; }
        .chapter-head:hover { background: var(--border); }

        /* The body is hidden by default */
        .chapter-body { display: none; padding: 10px; border-top: 1px solid var(--border); }
        .chapter-body.expanded { display: block; }

        .gallery-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; }
        .gallery-grid.merge-mode { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); }

        .gallery-item { position: relative; background: var(--panel-bg); border-radius: 6px; overflow: hidden; cursor: zoom-in; aspect-ratio: 2/3; border: 1px solid var(--border); }
        .gallery-item.merge-item { aspect-ratio: 4/3; }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }

        /* Filtered List Styling */
        .filtered-section { margin-top: 15px; border-top: 1px dashed var(--border); padding-top: 10px; }
        .filtered-toggle { font-size: 0.8rem; color: var(--warning-text); background: var(--warning-bg); padding: 5px 10px; border-radius: 6px; cursor: pointer; font-weight: 600; display: inline-block; }
        .filtered-list { display: none; margin-top: 10px; font-size: 0.75rem; color: var(--text-sub); background: var(--panel-bg); padding: 10px; border-radius: 8px; max-height: 150px; overflow-y: auto; }
        .filtered-list div { padding: 2px 0; border-bottom: 1px solid var(--border); }
        .filtered-list div:last-child { border: none; }

        /* Sticky Footer for Actions */
        .action-bar { position: fixed; bottom: 0; left: 0; width: 100%; background: var(--card-bg); padding: 15px; box-shadow: 0 -5px 20px rgba(0,0,0,0.1); display: none; justify-content: center; gap: 15px; border-top: 1px solid var(--border); z-index: 100; flex-wrap: wrap;}
        .btn { padding: 12px 24px; border: none; border-radius: 12px; font-weight: 700; cursor: pointer; font-size: 1rem; background: var(--primary); color: white; min-width: 130px; }
        .btn-secondary { background: var(--panel-bg); color: var(--text-main); border: 1px solid var(--border); }
        .btn-danger { background: var(--danger); color: white; }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; }

        /* Modal */
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: var(--modal-bg); align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal-content { max-width: 95vw; max-height: 90vh; }
        .modal img { max-width: 100%; max-height: 90vh; border-radius: 4px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        .close-modal { position: absolute; top: 20px; right: 20px; font-size: 40px; cursor: pointer; z-index: 2002; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div class="container">
    <div class="card">
        <div class="header-row">
            <div style="display:flex; align-items:center">
                <h1>Manga Tool</h1>
                <span id="img-count-badge" class="count-badge">0</span>
            </div>
            <button id="theme-toggle" class="mode-tab" style="flex:0; padding: 8px 12px;">ðŸŒ™</button>
        </div>

        <div class="mode-tabs">
            <button class="mode-tab active" id="tab-extract" onclick="setMode('extract')">Extract</button>
            <button class="mode-tab" id="tab-merge" onclick="setMode('merge')">Merger</button>
        </div>

        <div class="controls-wrapper">
            <div id="settings-extract" class="control-panel">
                <span class="control-label">Extraction Filters</span>
                <div class="range-row">
                    <span>Min Size:</span>
                    <input type="range" id="size-filter" min="0" max="200" value="40" step="5" onchange="triggerRefilter()">
                    <span id="size-val">40 KB</span>
                </div>
                <div class="toggle-row" style="margin-top:10px">
                    <span>Exclude GIFs</span>
                    <label class="switch"><input type="checkbox" id="no-gifs" checked onchange="triggerRefilter()"><span class="slider"></span></label>
                </div>
                <div class="toggle-row" style="margin-top:10px; border-top: 1px solid var(--border); padding-top: 10px;">
                    <span>Reverse Order</span>
                    <label class="switch"><input type="checkbox" id="reverse-sort" onchange="triggerRefilter()"><span class="slider"></span></label>
                </div>
            </div>

            <div id="settings-merge" class="control-panel hidden">
                <span class="control-label">Merger Settings</span>
                <div class="toggle-row">
                    <span>Manga Direction (RTL)</span>
                    <label class="switch"><input type="checkbox" id="rtl-mode" onchange="triggerRefilter()"><span class="slider"></span></label>
                </div>
            </div>
        </div>

        <div id="drop-zone" class="drop-zone">
            <input type="file" id="file-input" accept=".mhtml,.mht,.jpg,.jpeg,.png,.webp" multiple style="display:none">
            <span style="font-size: 2rem;">ðŸ“‚</span>
            <div class="drop-title"><b>Click to upload</b> MHTML or Images</div>
            <div style="font-size: 0.8rem; color: var(--text-sub); margin-top: 10px;">
                Drag & Drop supported (Unlimited Files)
            </div>
        </div>

        <div id="progress-area" class="progress-container">
            <div class="progress-info">
                <span id="status-text">Processing...</span>
                <span id="percent-text">0%</span>
            </div>
            <div class="progress-track"><div id="progress-bar" class="progress-fill"></div></div>
        </div>

        <div id="chapter-list" class="chapter-list"></div>
    </div>
</div>

<div id="action-bar" class="action-bar">
    <button id="add-more-btn" class="btn btn-secondary">Add More</button>
    <button id="download-btn" class="btn">Download All</button>
    <button id="reset-btn" class="btn btn-danger">Reset</button>
</div>

<div id="img-modal" class="modal" onclick="this.style.display='none'">
    <div class="close-modal">&times;</div>
    <div class="modal-content">
        <img id="modal-img" src="">
    </div>
</div>

<canvas id="merge-canvas" style="display:none;"></canvas>

<script id="worker-code" type="javascript/worker">
    self.onmessage = function(e) {
        const { type } = e.data;
        if (type === 'extractOne') extractSingleMhtml(e.data);
        if (type === 'zip') createZip(e.data);
    };

    function decodeQuotedPrintable(str) {
        return str.replace(/=[\r\n]+/g, "").replace(/=[0-9A-F]{2}/gi, function(v){
            return String.fromCharCode(parseInt(v.substr(1), 16));
        });
    }

    function extractSingleMhtml({ buffer, filename }) {
        const decoder = new TextDecoder("utf-8");
        const content = decoder.decode(buffer);
        let extracted = [];

        let boundary = null;
        const bMatch = content.match(/boundary="?([^";\s]+)"?/i);
        if (bMatch) boundary = bMatch[1];
        else {
            const match = content.match(/^--[a-fA-F0-9\-]+(\r?\n|$)/m);
            if(match) boundary = match[0].trim().replace(/^--/, '');
        }

        if (boundary) {
            const parts = content.split("--" + boundary);
            
            parts.forEach((part, idx) => {
                const sep = part.indexOf("\r\n\r\n");
                let bodyStart = sep, sepLen = 4;
                if(sep === -1) {
                    const sep2 = part.indexOf("\n\n");
                    if(sep2 !== -1) { bodyStart = sep2; sepLen = 2; } else return;
                }

                const headers = part.substring(0, bodyStart);
                let cleanBody = part.substring(bodyStart + sepLen).replace(/[\r\n]+$/, ""); 

                // Minimal filter to avoid total garbage (0 bytes)
                if (cleanBody.length < 10) return;

                const typeMatch = headers.match(/Content-Type:\s*image\/(jpeg|png|gif|webp)/i);
                const encodingMatch = headers.match(/Content-Transfer-Encoding:\s*(base64|quoted-printable)/i);

                const sortKey = String(idx).padStart(8, '0');

                if (typeMatch) {
                    const ext = typeMatch[1] === 'jpeg' ? 'jpg' : typeMatch[1];
                    try {
                        let bytes;
                        if (encodingMatch && encodingMatch[1].toLowerCase() === 'quoted-printable') {
                            cleanBody = decodeQuotedPrintable(cleanBody);
                            const bin = cleanBody.split('').map(c => c.charCodeAt(0));
                            bytes = new Uint8Array(bin);
                        } else {
                            const bin = atob(cleanBody.replace(/[\r\n\t\s]+/g, ""));
                            if (bin.length < 10) return; 
                            bytes = new Uint8Array(bin.length);
                            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
                        }
                        
                        // We extract ALL images here. Filtering happens on UI now.
                        extracted.push({ sortKey, data: bytes, ext, size: bytes.length });

                    } catch (err) { /* Skip corrupt parts */ }
                }
            });
        }

        // Just sort by file order initially
        extracted.sort((a,b) => a.sortKey.localeCompare(b.sortKey, undefined, {numeric:true}));

        const finalImages = extracted.map((item, i) => {
            return { 
                originalIdx: i,
                data: item.data, 
                ext: item.ext, 
                size: item.size 
            };
        });

        // Smart Rename
        let baseName = filename.replace(/\.mhtml?/i, "");
        const nameMatch = baseName.match(/^(.*?)(\b(?:chapter|ch\.?|vol\.?|volume)\s*[\d\.]+)(.*)$/i);
        if (nameMatch) {
            baseName = `${nameMatch[2].trim()} ${nameMatch[1].trim()} ${nameMatch[3].trim()}`.replace(/\s+/g, ' ').trim();
        }

        const group = finalImages.length > 0 ? { groupName: baseName, allImages: finalImages } : null;
        self.postMessage({ type: 'extractDone', group: group });
    }

    function createZip({ groups, extType }) {
        const crcTable = new Int32Array(256);
        for(let i=0; i<256; i++){let c=i; for(let k=0; k<8; k++) c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1)); crcTable[i]=c;}
        const crc32 = d => {let c=-1; for(let i=0;i<d.length;i++) c=(c>>>8)^crcTable[(c^d[i])&0xFF]; return (c^-1)>>>0;};

        const parts = [], cd = []; 
        let offset = 0; 
        const enc = new TextEncoder();

        let totalFiles = 0;
        groups.forEach(g => totalFiles += g.images.length);
        let processed = 0;

        for(const group of groups) {
            const cleanGroupName = group.groupName.replace(/[\\/:*?"<>|]/g, "_");
            const folderName = cleanGroupName + "/";

            for(const img of group.images) {
                processed++;
                if(processed % 10 === 0) {
                     self.postMessage({ type: 'status', text: "Compressing...", percent: (processed/totalFiles)*100 });
                }

                const path = folderName + img.name;
                const n = enc.encode(path); 
                const cr = crc32(img.data);

                const h = new Uint8Array(30+n.length); const v=new DataView(h.buffer);
                v.setUint32(0,0x04034b50,true); v.setUint16(4,10,true); v.setUint16(6,0,true); v.setUint16(8,0,true);
                v.setUint32(14,cr,true); v.setUint32(18,img.data.length,true); v.setUint32(22,img.data.length,true);
                v.setUint16(26,n.length,true); v.setUint16(28,0,true); h.set(n,30); 

                parts.push(h); parts.push(img.data);

                const c = new Uint8Array(46+n.length); const cv=new DataView(c.buffer);
                cv.setUint32(0,0x02014b50,true); cv.setUint16(4,10,true); cv.setUint16(6,10,true);
                cv.setUint16(8,0,true); cv.setUint16(10,0,true); cv.setUint32(16,cr,true);
                cv.setUint32(20,img.data.length,true); cv.setUint32(24,img.data.length,true);
                cv.setUint16(28,n.length,true); cv.setUint16(30,0,true); cv.setUint16(32,0,true);
                cv.setUint32(42,offset,true); c.set(n,46); 

                cd.push(c); offset += h.length + img.data.length;
            }
        }

        const cdLen = cd.reduce((a,c)=>a+c.length,0);
        const eocd = new Uint8Array(22); const ev=new DataView(eocd.buffer);
        ev.setUint32(0,0x06054b50,true); ev.setUint16(8,processed,true);
        ev.setUint16(10,processed,true); ev.setUint32(12,cdLen,true); ev.setUint32(16,offset,true);

        const blob = new Blob([...parts, ...cd, eocd], {type: 'application/zip'});
        self.postMessage({ type: 'zipDone', blob, filename: `Manga_Batch.${extType}` });
    }
</script>

<script>
    // --- MAIN THREAD ---
    let currentMode = 'extract';
    let rawGroups = []; 
    let activeUrls = []; 
    let worker = null;
    let processingQueue = [];
    let queueIndex = 0;
    let looseImagesBuffer = [];

    const els = {
        drop: document.getElementById('drop-zone'),
        input: document.getElementById('file-input'),
        progress: document.getElementById('progress-area'),
        bar: document.getElementById('progress-bar'),
        status: document.getElementById('status-text'),
        percent: document.getElementById('percent-text'),
        list: document.getElementById('chapter-list'),
        actionBar: document.getElementById('action-bar'),
        badge: document.getElementById('img-count-badge'),
        canvas: document.getElementById('merge-canvas'),
        settingsExtract: document.getElementById('settings-extract'),
        settingsMerge: document.getElementById('settings-merge'),
        downloadBtn: document.getElementById('download-btn'),
        addMoreBtn: document.getElementById('add-more-btn'),
        modal: document.getElementById('img-modal'),
        modalImg: document.getElementById('modal-img'),
        sizeFilter: document.getElementById('size-filter'),
        noGifs: document.getElementById('no-gifs'),
        reverse: document.getElementById('reverse-sort')
    };

    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');

    function init() {
        const blob = new Blob([document.getElementById('worker-code').textContent], {type: 'text/javascript'});
        worker = new Worker(URL.createObjectURL(blob));
        worker.onmessage = handleWorkerMsg;
        loadConfig();
    }

    function loadConfig() {
        const saved = JSON.parse(localStorage.getItem('manga-tool-cfg') || '{}');
        if(saved.minSize) els.sizeFilter.value = saved.minSize;
        if(saved.noGifs !== undefined) els.noGifs.checked = saved.noGifs;
        if(saved.reverse !== undefined) els.reverse.checked = saved.reverse;
        if(saved.rtl !== undefined) document.getElementById('rtl-mode').checked = saved.rtl;
        if(saved.theme) document.documentElement.setAttribute('data-theme', saved.theme);
        updateSizeLabel();
    }

    window.saveConfig = function() {
        const cfg = {
            minSize: els.sizeFilter.value,
            noGifs: els.noGifs.checked,
            reverse: els.reverse.checked,
            rtl: document.getElementById('rtl-mode').checked,
            theme: document.documentElement.getAttribute('data-theme')
        };
        localStorage.setItem('manga-tool-cfg', JSON.stringify(cfg));
        updateSizeLabel();
    };

    window.triggerRefilter = function() {
        saveConfig();
        applyFiltersToAll();
        clearAndRender();
    };

    function updateSizeLabel() {
        document.getElementById('size-val').innerText = els.sizeFilter.value + " KB";
    }

    // --- FILE HANDLING ---
    els.drop.onclick = () => els.input.click();
    els.addMoreBtn.onclick = () => els.input.click();
    els.input.onchange = () => { 
        if(els.input.files.length) handleFiles(els.input.files); 
        els.input.value = ''; 
    };

    els.drop.ondragover = (e) => { e.preventDefault(); els.drop.style.borderColor = 'var(--primary)'; };
    els.drop.ondragleave = (e) => { e.preventDefault(); els.drop.style.borderColor = 'var(--drop-border)'; };
    els.drop.ondrop = (e) => {
        e.preventDefault();
        els.drop.style.borderColor = 'var(--drop-border)';
        if(e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
    };

    async function handleFiles(files) {
        els.drop.style.display = 'none';
        els.progress.style.display = 'block';
        els.actionBar.style.display = 'none';
        processingQueue = Array.from(files); 
        queueIndex = 0;
        looseImagesBuffer = [];
        processNextFile();
    }

    async function processNextFile() {
        if (queueIndex >= processingQueue.length) {
            if (looseImagesBuffer.length > 0) {
                // For loose images, we treat them as pre-filtered candidates
                const looseCandidates = looseImagesBuffer.map((img, i) => ({
                    originalIdx: i, data: img.data, ext: img.ext, size: img.data.length
                }));
                rawGroups.push({ groupName: "Loose Images " + (rawGroups.length+1), allImages: looseCandidates });
            }
            finishProcessing();
            return;
        }

        const file = processingQueue[queueIndex];
        const pct = Math.round((queueIndex / processingQueue.length) * 100);
        updateProgress(`Reading ${queueIndex + 1}/${processingQueue.length}: ${file.name}`, pct);

        const name = file.name.toLowerCase();

        if (name.endsWith('.mhtml') || name.endsWith('.mht')) {
            try {
                const buf = await file.arrayBuffer();
                worker.postMessage({ 
                    type: 'extractOne', 
                    buffer: buf, 
                    filename: file.name
                    // No config sent, we extract EVERYTHING now
                }, [buf]); 
            } catch (err) { queueIndex++; processNextFile(); }
        } 
        else if (name.match(/\.(jpg|jpeg|png|webp)$/)) {
            try {
                const buf = await file.arrayBuffer();
                looseImagesBuffer.push({ name: file.name, data: new Uint8Array(buf), ext: name.split('.').pop() });
            } catch (e) {}
            queueIndex++;
            processNextFile(); 
        }
        else { queueIndex++; processNextFile(); }
    }

    function handleWorkerMsg(e) {
        const { type, text, percent, group, blob, filename } = e.data;

        if(type === 'status') {
            updateProgress(text, percent);
        }
        else if (type === 'extractDone') {
            if (group) rawGroups.push(group);
            queueIndex++;
            processNextFile();
        }
        else if (type === 'zipDone') {
            downloadBlob(blob, filename);
            els.downloadBtn.disabled = false;
            els.downloadBtn.innerText = "Download All";
            updateProgress("Complete!", 100);
            setTimeout(() => els.progress.style.display = 'none', 2000);
        }
    }

    function updateProgress(text, pct) {
        els.status.innerText = text;
        els.bar.style.width = pct + "%";
        els.percent.innerText = Math.round(pct) + "%";
    }

    function finishProcessing() {
        els.progress.style.display = 'none';
        els.actionBar.style.display = 'flex';
        applyFiltersToAll();
        clearAndRender();
    }

    // --- FILTERING LOGIC ---
    function applyFiltersToAll() {
        const minSize = parseInt(els.sizeFilter.value) * 1024;
        const noGifs = els.noGifs.checked;
        const reverse = els.reverse.checked;

        rawGroups.forEach(group => {
            // Filter
            const valid = [];
            const filtered = [];

            group.allImages.forEach(img => {
                let reason = null;
                if (img.size < minSize) reason = `Too Small (${Math.round(img.size/1024)}KB)`;
                else if (noGifs && img.ext === 'gif') reason = "GIF Excluded";

                if (reason) {
                    filtered.push({ ...img, reason });
                } else {
                    valid.push(img);
                }
            });

            // Sort
            if (reverse) valid.reverse(); // Note: This reverses the original order
            
            // Renumber for display
            group.displayImages = valid.map((img, i) => ({
                ...img,
                name: `${String(i+1).padStart(3, '0')}.${img.ext}`
            }));
            
            group.filteredList = filtered;
        });
        
        updateBadge();
    }

    function updateBadge() {
        const totalImages = rawGroups.reduce((acc, g) => acc + g.displayImages.length, 0);
        els.badge.style.display = 'inline-block';
        els.badge.innerText = `${rawGroups.length} Files / ${totalImages} imgs`;
    }

    // --- RENDER LOGIC ---
    function clearAndRender() {
        els.list.innerHTML = '';
        rawGroups.forEach((group, idx) => {
            const item = document.createElement('div');
            item.className = 'chapter-item';
            
            // Header
            const head = document.createElement('div');
            head.className = 'chapter-head';
            head.innerHTML = `<span>${group.groupName}</span> <span style="font-size:0.8em; color:var(--text-sub)">${group.displayImages.length} images</span>`;
            
            const removeBtn = document.createElement('span');
            removeBtn.innerHTML = " &times;";
            removeBtn.style.color = "var(--danger)";
            removeBtn.style.marginLeft = "10px";
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                rawGroups.splice(idx, 1);
                applyFiltersToAll(); // Update badge
                clearAndRender();
            };
            head.appendChild(removeBtn);

            // Body
            const body = document.createElement('div');
            body.className = 'chapter-body';

            head.onclick = () => toggleChapter(body, group);
            item.appendChild(head);
            item.appendChild(body);

            // Filtered Items Section (Lazy render inside body when opened, but setup structure here)
            // We'll append it to body later inside toggleChapter or just render it now if simple
            els.list.appendChild(item);
        });
    }

    async function toggleChapter(container, group) {
        if (container.classList.contains('expanded')) {
            container.classList.remove('expanded');
            container.innerHTML = ''; 
            return;
        }

        container.classList.add('expanded');
        container.innerHTML = '<div style="padding:10px; text-align:center">Generating previews...</div>';
        await new Promise(r => setTimeout(r, 10));

        const grid = document.createElement('div');
        grid.className = currentMode === 'extract' ? 'gallery-grid' : 'gallery-grid merge-mode';
        const isRTL = document.getElementById('rtl-mode').checked;

        const items = currentMode === 'extract' ? group.displayImages : pairImages(group.displayImages);
        const limit = Math.min(items.length, 30);

        for(let i=0; i<limit; i++) {
            let url;
            if(currentMode === 'extract') {
                const img = items[i];
                url = URL.createObjectURL(new Blob([img.data], {type: 'image/'+img.ext}));
            } else {
                url = await createMergedUrl(items[i], isRTL);
            }
            activeUrls.push(url);
            addToGrid(grid, url, currentMode !== 'extract');
        }

        if(items.length > limit) {
             const more = document.createElement('div');
             more.innerText = `+${items.length - limit} more pages`;
             more.style.gridColumn = "1/-1";
             more.style.textAlign = "center";
             more.style.padding = "10px";
             more.style.color = "var(--text-sub)";
             grid.appendChild(more);
        }

        container.innerHTML = '';
        container.appendChild(grid);

        // --- RENDER FILTERED LIST ---
        if (group.filteredList && group.filteredList.length > 0) {
            const filterSection = document.createElement('div');
            filterSection.className = 'filtered-section';
            
            const toggle = document.createElement('div');
            toggle.className = 'filtered-toggle';
            toggle.innerText = `âš ï¸ ${group.filteredList.length} items excluded by filters`;
            
            const list = document.createElement('div');
            list.className = 'filtered-list';
            
            // Build text list
            group.filteredList.forEach((f, idx) => {
                const r = document.createElement('div');
                r.innerText = `#${f.originalIdx} .${f.ext} - ${f.reason}`;
                list.appendChild(r);
            });

            toggle.onclick = () => {
                list.style.display = list.style.display === 'block' ? 'none' : 'block';
            };

            filterSection.appendChild(toggle);
            filterSection.appendChild(list);
            container.appendChild(filterSection);
        }
    }

    function pairImages(images) {
        const pairs = [];
        for(let i=0; i<images.length; i+=2) {
            pairs.push(images.slice(i, i+2)); 
        }
        return pairs;
    }

    async function createMergedUrl(pair, isRTL) {
        const ctx = els.canvas.getContext('2d');
        const b1 = await createImageBitmap(new Blob([pair[0].data]));
        let b2 = null;
        if(pair[1]) b2 = await createImageBitmap(new Blob([pair[1].data]));

        if(!b2) {
            els.canvas.width = b1.width;
            els.canvas.height = b1.height;
            ctx.drawImage(b1, 0, 0);
        } else {
            els.canvas.width = b1.width + b2.width;
            els.canvas.height = Math.max(b1.height, b2.height);
            ctx.fillStyle="#fff"; ctx.fillRect(0,0,els.canvas.width,els.canvas.height);

            if(isRTL) {
                ctx.drawImage(b2, 0, 0);
                ctx.drawImage(b1, b2.width, 0);
            } else {
                ctx.drawImage(b1, 0, 0);
                ctx.drawImage(b2, b1.width, 0);
            }
        }

        return new Promise(r => els.canvas.toBlob(blob => r(URL.createObjectURL(blob)), 'image/jpeg', 0.85));
    }

    function addToGrid(grid, url, isMerge) {
        const div = document.createElement('div');
        div.className = `gallery-item ${isMerge?'merge-item':''}`;
        div.innerHTML = `<img src="${url}" loading="lazy">`;
        div.onclick = () => openModal(url);
        grid.appendChild(div);
    }

    // --- DOWNLOAD LOGIC ---
    els.downloadBtn.onclick = async () => {
        if(!rawGroups.length) return;

        els.downloadBtn.disabled = true;
        els.downloadBtn.innerText = "Processing...";
        els.progress.style.display = 'block';

        let finalGroups = [];
        // Use group.displayImages for download (respects filters)
        
        if(currentMode === 'merge') {
            updateProgress("Merging images for export...", 0);
            const isRTL = document.getElementById('rtl-mode').checked;

            for(let i=0; i<rawGroups.length; i++) {
                const g = rawGroups[i];
                const pairs = pairImages(g.displayImages);
                const mergedImages = [];

                for(let j=0; j<pairs.length; j++) {
                    if(j%5===0) updateProgress(`Merging ${g.groupName} (${j}/${pairs.length})`, (i/rawGroups.length)*100);

                    const url = await createMergedUrl(pairs[j], isRTL);
                    const res = await fetch(url);
                    const blob = await res.blob();
                    const buf = await blob.arrayBuffer();

                    mergedImages.push({
                        name: `page_${String(j).padStart(4,'0')}.jpg`,
                        data: new Uint8Array(buf),
                        ext: 'jpg'
                    });
                    URL.revokeObjectURL(url); 
                }
                finalGroups.push({ groupName: g.groupName, images: mergedImages });
            }
        } else {
             // Extract mode: Use the filtered 'displayImages'
             finalGroups = rawGroups.map(g => ({
                 groupName: g.groupName,
                 images: g.displayImages
             }));
        }

        updateProgress("Generating Archive...", 90);
        worker.postMessage({ type: 'zip', groups: finalGroups, extType: 'cbz' });
    };

    // --- UTILS & MODAL ---
    window.setMode = (mode) => {
        currentMode = mode;
        document.querySelectorAll('.mode-tab').forEach(b => b.classList.remove('active'));
        document.getElementById(`tab-${mode}`).classList.add('active');
        els.settingsExtract.classList.toggle('hidden', mode !== 'extract');
        els.settingsMerge.classList.toggle('hidden', mode === 'extract');
        clearAndRender();
    };

    document.getElementById('reset-btn').onclick = () => {
        activeUrls.forEach(u => URL.revokeObjectURL(u));
        location.reload();
    };

    document.getElementById('theme-toggle').onclick = () => {
        const html = document.documentElement;
        const newT = html.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
        html.setAttribute('data-theme', newT);
        saveConfig();
    };

    function openModal(src) {
        els.modalImg.src = src;
        els.modal.style.display = 'flex';
    }

    document.onkeydown = (e) => {
        if(els.modal.style.display === 'flex') {
            if(e.key === 'Escape') els.modal.style.display = 'none';
        }
    };

    function downloadBlob(blob, name) {
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = name;
        a.click();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    init();
</script>
</body>
</html>

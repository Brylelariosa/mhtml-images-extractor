<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#4f46e5">
    <title>Manga Tool Ultimate</title>
    <link rel="manifest" href="manifest.json">
    <style>
        :root { --primary: #4f46e5; --bg: #f8fafc; --card: #ffffff; --text: #1e293b; --border: #e2e8f0; }
        [data-theme="dark"] { --primary: #6366f1; --bg: #0f172a; --card: #1e293b; --text: #f1f5f9; --border: #334155; }
        
        body { margin:0; font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); padding-bottom: 80px; }
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        
        /* Drop Zone */
        #drop-zone { border: 2px dashed var(--border); border-radius: 12px; padding: 40px; text-align: center; cursor: pointer; transition: 0.2s; background: var(--card); }
        #drop-zone:hover { border-color: var(--primary); background: rgba(79, 70, 229, 0.05); }
        
        /* Controls */
        .controls { display: flex; gap: 10px; margin: 20px 0; flex-wrap: wrap; }
        button { background: var(--primary); color: white; border: none; padding: 10px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        button.secondary { background: transparent; border: 1px solid var(--border); color: var(--text); }
        
        /* Toggles */
        .toggle-row { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Chapter List */
        .chapter { background: var(--card); margin-bottom: 10px; border-radius: 8px; border: 1px solid var(--border); overflow: hidden; }
        .chap-head { padding: 15px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none; }
        .chap-head:hover { background: rgba(0,0,0,0.02); }
        .chap-actions { display: flex; gap: 10px; align-items: center; }
        .icon-btn { cursor: pointer; padding: 4px; border-radius: 4px; font-size: 1.2em; }
        .icon-btn:hover { background: rgba(0,0,0,0.1); }
        
        .chap-content { display: none; padding: 15px; border-top: 1px solid var(--border); }
        .chap-content.open { display: block; }
        
        /* Grid */
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; }
        .grid img { width: 100%; height: auto; border-radius: 4px; display: block; }
        .grid .merged-spread { grid-column: span 2; } 
        
        #progress { display: none; margin-top: 10px; font-size: 0.9em; color: var(--primary); }
    </style>
</head>
<body>

<div class="container">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
        <h2>Manga Tool Ult.</h2>
        <button id="theme-toggle" class="secondary">ðŸŒ™</button>
    </div>

    <div id="drop-zone">
        <h3>Drag & Drop MHTML files</h3>
        <p style="color:var(--text-sub)">or click to browse</p>
        <input type="file" id="file-input" multiple accept=".mhtml,.mht" style="display:none">
    </div>

    <div id="progress">Processing...</div>

    <div class="controls" id="main-controls" style="display:none;">
        <button id="dl-all-btn">Download All (Zip)</button>
        <button id="reset-btn" class="secondary">Clear</button>
        
        <div style="width:100%"></div> <div class="toggle-row">
            <span>Merge Spreads</span>
            <label class="switch"><input type="checkbox" id="merge-mode" onchange="renderAll()"><span class="slider"></span></label>
        </div>
        <div class="toggle-row">
            <span>First Page is Cover</span>
            <label class="switch"><input type="checkbox" id="cover-mode" onchange="renderAll()"><span class="slider"></span></label>
        </div>
    </div>

    <div id="chapter-list"></div>
</div>

<script>
    // State
    let worker;
    let rawGroups = [];
    let processingQueue = [];
    let processedCount = 0;

    // Elements
    const els = {
        drop: document.getElementById('drop-zone'),
        input: document.getElementById('file-input'),
        list: document.getElementById('chapter-list'),
        progress: document.getElementById('progress'),
        controls: document.getElementById('main-controls'),
        dlBtn: document.getElementById('dl-all-btn'),
        merge: document.getElementById('merge-mode'),
        cover: document.getElementById('cover-mode')
    };

    function init() {
        // Init Worker
        worker = new Worker('worker.js');
        worker.onmessage = handleWorkerMsg;
        
        // Init Service Worker
        if('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(() => console.log('SW Registered'))
                .catch(err => console.log('SW Fail:', err));
        }

        // Theme
        if(localStorage.getItem('theme') === 'dark') document.documentElement.setAttribute('data-theme', 'dark');

        // Events
        els.drop.onclick = () => els.input.click();
        els.drop.ondragover = e => { e.preventDefault(); els.drop.style.borderColor = 'var(--primary)'; };
        els.drop.ondragleave = () => els.drop.style.borderColor = 'var(--border)';
        els.drop.ondrop = e => {
            e.preventDefault();
            els.drop.style.borderColor = 'var(--border)';
            handleFiles(e.dataTransfer.files);
        };
        els.input.onchange = e => handleFiles(e.target.files);
        
        document.getElementById('theme-toggle').onclick = () => {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            document.documentElement.setAttribute('data-theme', isDark ? 'light' : 'dark');
            localStorage.setItem('theme', isDark ? 'light' : 'dark');
        };

        els.dlBtn.onclick = () => {
            if(!rawGroups.length) return;
            setBtnState(true, 'Zipping...');
            worker.postMessage({ type: 'zip', groups: rawGroups });
        };
        
        document.getElementById('reset-btn').onclick = () => location.reload();
    }

    async function handleFiles(files) {
        if(!files.length) return;
        
        els.drop.style.display = 'none';
        els.progress.style.display = 'block';
        els.progress.innerText = `Preparing ${files.length} files...`;

        // 1. Sort files naturally (Chapter 1, Chapter 2, Chapter 10)
        processingQueue = Array.from(files).sort((a, b) => 
            a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' })
        );

        // 2. Start processing queue
        processedCount = 0;
        processNext();
    }

    function processNext() {
        if (processedCount >= processingQueue.length) {
            els.progress.style.display = 'none';
            els.controls.style.display = 'flex';
            renderAll();
            return;
        }

        const file = processingQueue[processedCount];
        els.progress.innerText = `Extracting ${processedCount + 1}/${processingQueue.length}: ${file.name}`;
        
        worker.postMessage({ type: 'extractOne', file: file, fileId: processedCount });
    }

    function handleWorkerMsg(e) {
        const { type, fileId, groupName, images, blob, filename } = e.data;

        if (type === 'done') {
            rawGroups.push({ groupName, images });
            processedCount++;
            processNext();
        } 
        else if (type === 'zipDone') {
            downloadBlob(blob, filename);
            setBtnState(false, 'Download All (Zip)');
        }
        else if (type === 'error') {
            console.error(e.data.message);
            processedCount++;
            processNext(); // Skip and continue
        }
    }

    function renderAll() {
        els.list.innerHTML = '';
        // Sort groups again by name just in case async messed order
        rawGroups.sort((a,b) => a.groupName.localeCompare(b.groupName, undefined, {numeric:true}));
        
        rawGroups.forEach((group, idx) => {
            renderChapter(group, idx);
        });
    }

    function renderChapter(group, idx) {
        const div = document.createElement('div');
        div.className = 'chapter';
        
        // Header
        const head = document.createElement('div');
        head.className = 'chap-head';
        
        // Title
        const title = document.createElement('span');
        title.innerHTML = `<b>${group.groupName}</b> <small>(${group.images.length} pages)</small>`;
        
        // Actions
        const actions = document.createElement('div');
        actions.className = 'chap-actions';
        
        // Download Single Button
        const dlSingle = document.createElement('span');
        dlSingle.innerText = 'â¬‡ï¸';
        dlSingle.className = 'icon-btn';
        dlSingle.title = "Download this chapter only";
        dlSingle.onclick = (e) => {
            e.stopPropagation();
            setBtnState(true, 'Zipping Single...');
            worker.postMessage({ type: 'zip', groups: [group] });
        };
        
        actions.appendChild(dlSingle);
        head.appendChild(title);
        head.appendChild(actions);

        // Content
        const content = document.createElement('div');
        content.className = 'chap-content';
        
        // Accordion toggle
        head.onclick = () => {
            const isOpen = content.classList.contains('open');
            // Close others (optional, keep it simple for now)
            content.classList.toggle('open');
            if(!isOpen && !content.hasChildNodes()) {
                renderImages(content, group);
            }
        };

        div.appendChild(head);
        div.appendChild(content);
        els.list.appendChild(div);
    }

    function renderImages(container, group) {
        const grid = document.createElement('div');
        grid.className = 'grid';
        
        const isMerge = els.merge.checked;
        const isCover = els.cover.checked;
        
        let i = 0;
        
        // Handle Cover (First page alone)
        if (isMerge && isCover && group.images.length > 0) {
            appendImg(grid, group.images[0], true);
            i = 1;
        }

        // Loop rest
        while(i < group.images.length) {
            if(isMerge && i + 1 < group.images.length) {
                // Merge Pair
                appendMerged(grid, group.images[i], group.images[i+1]);
                i += 2;
            } else {
                // Single Page
                appendImg(grid, group.images[i], false);
                i++;
            }
        }
        container.appendChild(grid);
    }

    function appendImg(grid, imgObj, isCenter) {
        const blob = new Blob([imgObj.data], {type: 'image/jpeg'});
        const img = document.createElement('img');
        img.src = URL.createObjectURL(blob);
        if(isCenter) {
            img.style.gridColumn = "span 2"; 
            img.style.width = "50%";
            img.style.margin = "0 auto";
        }
        grid.appendChild(img);
    }

    function appendMerged(grid, imgLeft, imgRight) {
        // Logic to canvas merge could go here, 
        // but for visual "Reader" mode, we just place them side-by-side in CSS
        // or actually merge them into one canvas?
        // Since user asked for "Merger Tool", let's do visual merge for now
        // A true canvas merge is heavy on memory for DOM, better to just show side by side
        
        // Visual Merge Wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'merged-spread';
        wrapper.style.display = 'flex';
        
        const b1 = new Blob([imgLeft.data]);
        const b2 = new Blob([imgRight.data]);
        
        const i1 = document.createElement('img'); i1.src = URL.createObjectURL(b1); i1.style.width='50%';
        const i2 = document.createElement('img'); i2.src = URL.createObjectURL(b2); i2.style.width='50%';
        
        // Manga is usually Right-to-Left, so Right Page is First in array? 
        // Usually file names are 001, 002. 
        // 002 is Left, 001 is Right.
        // Let's assume standard LTR file ordering for now.
        
        wrapper.appendChild(i1);
        wrapper.appendChild(i2);
        grid.appendChild(wrapper);
    }

    function downloadBlob(blob, name) {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = name;
        a.click();
    }

    function setBtnState(disabled, text) {
        els.dlBtn.disabled = disabled;
        const old = els.dlBtn.innerText;
        els.dlBtn.innerText = text;
        if(!disabled) setTimeout(() => els.dlBtn.innerText = 'Download All (Zip)', 2000);
    }

    init();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#4f46e5">
    <meta name="description" content="Manga Extractor & Merger Tool">
    <title>Manga Tool Ultimate</title>
    
    <link rel="manifest" href="manifest.json">

    <style>
        :root { --primary: #4f46e5; --bg-color: #f8fafc; --card-bg: #ffffff; --text-main: #1e293b; --text-sub: #64748b; --border: #e2e8f0; --panel-bg: #f1f5f9; --drop-bg: #f8fafc; --drop-border: #cbd5e1; --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.05); --modal-bg: rgba(255, 255, 255, 0.98); }
        [data-theme="dark"] { --primary: #6366f1; --bg-color: #0f172a; --card-bg: #1e293b; --text-main: #f1f5f9; --text-sub: #94a3b8; --border: #334155; --panel-bg: #0f172a; --drop-bg: #1e293b; --drop-border: #475569; --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5); --modal-bg: rgba(15, 23, 42, 0.98); }
        
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg-color); color: var(--text-main); display: flex; justify-content: center; align-items: start; min-height: 100vh; margin: 0; padding: 20px; padding-bottom: 100px; transition: 0.3s; }
        
        .container { width: 100%; max-width: 900px; }
        .card { background: var(--card-bg); border-radius: 16px; box-shadow: var(--shadow); padding: 1.5rem; border: 1px solid var(--border); }
        
        /* Header */
        .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
        h1 { margin: 0; font-size: 1.5rem; font-weight: 800; letter-spacing: -0.5px; }
        .count-badge { font-size: 0.8rem; background: var(--primary); color: white; padding: 4px 10px; border-radius: 20px; margin-left: 10px; display: none;}
        
        /* Tabs */
        .mode-tabs { display: flex; background: var(--panel-bg); padding: 4px; border-radius: 12px; gap: 4px; border: 1px solid var(--border); margin-bottom: 1.5rem; }
        .mode-tab { flex: 1; border: none; background: transparent; padding: 10px; font-weight: 600; color: var(--text-sub); border-radius: 8px; cursor: pointer; transition: 0.2s; font-size: 0.9rem; }
        .mode-tab.active { background: var(--card-bg); color: var(--primary); box-shadow: 0 2px 8px rgba(0,0,0,0.08); }

        /* Controls */
        .controls-wrapper { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; margin-bottom: 1.5rem; }
        .control-panel { background: var(--panel-bg); padding: 1rem; border-radius: 12px; border: 1px solid var(--border); }
        .control-label { display: block; font-size: 0.7rem; font-weight: 700; text-transform: uppercase; color: var(--text-sub); margin-bottom: 0.8rem; }
        
        .range-row { display: flex; align-items: center; gap: 10px; font-size: 0.9rem; font-weight: 600; }
        input[type=range] { flex: 1; accent-color: var(--primary); }
        
        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; font-size: 0.9rem; font-weight: 500; }
        .switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--drop-border); transition: .3s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .3s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(16px); }

        .btn-sm { font-size: 0.75rem; padding: 4px 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--card-bg); cursor: pointer; color: var(--text-main); font-weight: 600; transition:0.2s; }
        .btn-sm:hover { background: var(--primary); color: white; border-color: var(--primary); }

        /* Upload */
        .drop-zone { border: 2px dashed var(--drop-border); border-radius: 12px; padding: 3rem 2rem; text-align: center; cursor: pointer; background: var(--drop-bg); transition: 0.2s; }
        .drop-zone:hover { border-color: var(--primary); background: rgba(79, 70, 229, 0.05); transform: scale(0.99); }
        
        /* Progress */
        .progress-container { margin-top: 2rem; display: none; }
        .progress-info { display: flex; justify-content: space-between; font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; }
        .progress-track { width: 100%; height: 6px; background: var(--border); border-radius: 10px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.1s linear; }

        /* Gallery / List View */
        .chapter-list { margin-top: 2rem; display: flex; flex-direction: column; gap: 10px; }
        .chapter-item { border: 1px solid var(--border); border-radius: 8px; overflow: hidden; background: var(--card-bg); }
        .chapter-head { padding: 12px 15px; display: flex; justify-content: space-between; align-items: center; background: var(--panel-bg); cursor: pointer; user-select: none; font-weight: 600; font-size: 0.9rem; }
        .chapter-head:hover { background: var(--border); }
        
        /* The body is hidden by default */
        .chapter-body { display: none; padding: 10px; border-top: 1px solid var(--border); }
        .chapter-body.expanded { display: block; }
        
        .gallery-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; }
        .gallery-grid.merge-mode { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); }
        
        .gallery-item { position: relative; background: var(--panel-bg); border-radius: 6px; overflow: hidden; cursor: zoom-in; aspect-ratio: 2/3; border: 1px solid var(--border); }
        .gallery-item.merge-item { aspect-ratio: 4/3; }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }

        /* Sticky Footer for Actions */
        .action-bar { position: fixed; bottom: 0; left: 0; width: 100%; background: var(--card-bg); padding: 15px; box-shadow: 0 -5px 20px rgba(0,0,0,0.1); display: none; justify-content: center; gap: 15px; border-top: 1px solid var(--border); z-index: 100; }
        .btn { padding: 12px 24px; border: none; border-radius: 12px; font-weight: 700; cursor: pointer; font-size: 1rem; background: var(--primary); color: white; min-width: 140px; }
        .btn-danger { background: #ef4444; color: white; }
        .btn:disabled { opacity: 0.7; cursor: not-allowed; }

        /* Modal */
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: var(--modal-bg); align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal-content { max-width: 95vw; max-height: 90vh; }
        .modal img { max-width: 100%; max-height: 90vh; border-radius: 4px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        .close-modal { position: absolute; top: 20px; right: 20px; font-size: 40px; cursor: pointer; z-index: 2002; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div class="container">
    <div class="card">
        <div class="header-row">
            <div style="display:flex; align-items:center">
                <h1>Manga Tool</h1>
                <span id="img-count-badge" class="count-badge">0</span>
            </div>
            <button id="theme-toggle" class="mode-tab" style="flex:0; padding: 8px 12px;">ðŸŒ™</button>
        </div>

        <div class="mode-tabs">
            <button class="mode-tab active" id="tab-extract" onclick="setMode('extract')">Extract</button>
            <button class="mode-tab" id="tab-merge" onclick="setMode('merge')">Merger</button>
        </div>

        <div class="controls-wrapper">
            <div id="settings-extract" class="control-panel">
                <span class="control-label">Extraction Filters</span>
                <div class="range-row">
                    <span>Min Size:</span>
                    <input type="range" id="size-filter" min="0" max="200" value="40" step="5" onchange="saveConfig()">
                    <span id="size-val">40 KB</span>
                </div>
                <div class="toggle-row" style="margin-top:10px">
                    <span>Exclude GIFs</span>
                    <label class="switch"><input type="checkbox" id="no-gifs" checked onchange="saveConfig()"><span class="slider"></span></label>
                </div>
                <div class="toggle-row" style="margin-top:10px; border-top: 1px solid var(--border); padding-top: 10px;">
                    <span>Reverse Order</span>
                    <label class="switch"><input type="checkbox" id="reverse-sort" onchange="saveConfig()"><span class="slider"></span></label>
                </div>
            </div>

            <div id="settings-merge" class="control-panel hidden">
                <span class="control-label">Merger Settings</span>
                <div class="toggle-row">
                    <span>Manga Direction (RTL)</span>
                    <label class="switch"><input type="checkbox" id="rtl-mode" onchange="saveConfig(); clearAndRender()"><span class="slider"></span></label>
                </div>
                <div class="toggle-row" style="margin-top:10px; border-top: 1px solid var(--border); padding-top: 10px;">
                    <span>Fix Offset</span>
                    <button class="btn-sm" onclick="shiftImages()">Shift (+1 Blank)</button>
                </div>
            </div>
        </div>

        <div id="drop-zone" class="drop-zone">
            <input type="file" id="file-input" accept=".mhtml,.mht,.jpg,.jpeg,.png,.webp" multiple style="display:none">
            <span style="font-size: 2rem;">ðŸ“‚</span>
            <div class="drop-title"><b>Click to upload</b> MHTML or Images</div>
            <div style="font-size: 0.8rem; color: var(--text-sub); margin-top: 10px;">
                Drag & Drop supported
            </div>
        </div>

        <div id="progress-area" class="progress-container">
            <div class="progress-info">
                <span id="status-text">Processing...</span>
                <span id="percent-text">0%</span>
            </div>
            <div class="progress-track"><div id="progress-bar" class="progress-fill"></div></div>
        </div>

        <div id="chapter-list" class="chapter-list"></div>
    </div>
</div>

<div id="action-bar" class="action-bar">
    <button id="reset-btn" class="btn btn-danger">Reset</button>
    <button id="download-btn" class="btn">Download All</button>
</div>

<div id="img-modal" class="modal" onclick="this.style.display='none'">
    <div class="close-modal">&times;</div>
    <div class="modal-content">
        <img id="modal-img" src="">
    </div>
</div>

<canvas id="merge-canvas" style="display:none;"></canvas>

<script id="worker-code" type="javascript/worker">
    self.onmessage = function(e) {
        const { type } = e.data;
        if (type === 'extract') extractMhtml(e.data);
        if (type === 'zip') createZip(e.data);
    };

    function extractMhtml({ contents, filenames, config }) {
        const resultGroups = [];

        function parseMHTML(content, fileName) {
            // Find boundary
            let boundary = null;
            const bMatch = content.match(/boundary="?([^";\s]+)"?/i);
            if (bMatch) boundary = bMatch[1];
            else {
                const match = content.match(/^--[a-fA-F0-9\-]+(\r?\n|$)/m);
                if(match) boundary = match[0].trim().replace(/^--/, '');
            }
            if (!boundary) return [];

            const parts = content.split("--" + boundary);
            const extracted = [];
            const minSizeBytes = config.minSizeKB * 1024;

            parts.forEach((part, idx) => {
                // Find empty line separating headers from body
                const sep = part.indexOf("\r\n\r\n");
                let bodyStart = sep, sepLen = 4;
                if(sep === -1) {
                    const sep2 = part.indexOf("\n\n");
                    if(sep2 !== -1) { bodyStart = sep2; sepLen = 2; } else return;
                }

                const headers = part.substring(0, bodyStart);
                const body = part.substring(bodyStart + sepLen);
                const typeMatch = headers.match(/Content-Type:\s*image\/(jpeg|png|gif|webp)/i);
                
                if (typeMatch) {
                    const ext = typeMatch[1] === 'jpeg' ? 'jpg' : typeMatch[1];
                    if (config.excludeGifs && ext === 'gif') return;
                    
                    // Cleanup and Base64 check
                    const cleanBody = body.replace(/[\r\n\t\s]+/g, "");
                    // rough size check before decoding
                    if (cleanBody.length * 0.75 < minSizeBytes) return;

                    try {
                        const bin = atob(cleanBody);
                        if (bin.length >= minSizeBytes) {
                            const bytes = new Uint8Array(bin.length);
                            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
                            // Pad name for sorting
                            const name = `img_${String(idx).padStart(4,'0')}.${ext}`;
                            extracted.push({ name, data: bytes, ext });
                        }
                    } catch (err) {}
                }
            });
            return extracted;
        }

        try {
            for (let i = 0; i < contents.length; i++) {
                self.postMessage({ type: 'status', text: `Scanning ${filenames[i]}...`, percent: (i/contents.length)*40 });
                const imgs = parseMHTML(contents[i], filenames[i]);
                
                imgs.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric:true}));
                if(config.reverse) imgs.reverse();

                if(imgs.length > 0) {
                    resultGroups.push({ groupName: filenames[i].replace(/\.mhtml?/i, ""), images: imgs });
                }
            }
            self.postMessage({ type: 'extractDone', groups: resultGroups });
        } catch (e) {
            self.postMessage({ type: 'error', msg: e.message });
        }
    }

    // ZIP LOGIC: Creates FOLDERS instead of nested Zips
    function createZip({ groups }) {
        const crcTable = new Int32Array(256);
        for(let i=0; i<256; i++){let c=i; for(let k=0; k<8; k++) c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1)); crcTable[i]=c;}
        const crc32 = d => {let c=-1; for(let i=0;i<d.length;i++) c=(c>>>8)^crcTable[(c^d[i])&0xFF]; return (c^-1)>>>0;};

        const parts = [], cd = []; 
        let offset = 0; 
        const enc = new TextEncoder();

        let totalFiles = 0;
        groups.forEach(g => totalFiles += g.images.length);
        let processed = 0;

        for(const group of groups) {
            // Clean folder name
            const folderName = group.groupName.trim() + "/";
            
            for(const img of group.images) {
                processed++;
                if(processed % 20 === 0) {
                     self.postMessage({ type: 'status', text: "Zipping...", percent: 50 + ((processed/totalFiles)*50) });
                }

                // Path = Folder/Image.jpg
                const path = folderName + img.name;
                const n = enc.encode(path); 
                const cr = crc32(img.data);
                
                const h = new Uint8Array(30+n.length); const v=new DataView(h.buffer);
                v.setUint32(0,0x04034b50,true); v.setUint16(4,10,true); v.setUint16(6,0,true); v.setUint16(8,0,true);
                v.setUint32(14,cr,true); v.setUint32(18,img.data.length,true); v.setUint32(22,img.data.length,true);
                v.setUint16(26,n.length,true); v.setUint16(28,0,true); h.set(n,30); 
                
                parts.push(h); parts.push(img.data);

                const c = new Uint8Array(46+n.length); const cv=new DataView(c.buffer);
                cv.setUint32(0,0x02014b50,true); cv.setUint16(4,10,true); cv.setUint16(6,10,true);
                cv.setUint16(8,0,true); cv.setUint16(10,0,true); cv.setUint32(16,cr,true);
                cv.setUint32(20,img.data.length,true); cv.setUint32(24,img.data.length,true);
                cv.setUint16(28,n.length,true); cv.setUint16(30,0,true); cv.setUint16(32,0,true);
                cv.setUint32(42,offset,true); c.set(n,46); 
                
                cd.push(c); offset += h.length + img.data.length;
            }
        }

        const cdLen = cd.reduce((a,c)=>a+c.length,0);
        const eocd = new Uint8Array(22); const ev=new DataView(eocd.buffer);
        ev.setUint32(0,0x06054b50,true); ev.setUint16(8,processed,true);
        ev.setUint16(10,processed,true); ev.setUint32(12,cdLen,true); ev.setUint32(16,offset,true);
        
        const blob = new Blob([...parts, ...cd, eocd], {type: 'application/zip'});
        self.postMessage({ type: 'zipDone', blob, filename: "Manga_Batch.zip" });
    }
</script>

<script>
    // --- MAIN THREAD ---
    let currentMode = 'extract';
    let rawGroups = []; 
    let activeUrls = []; // Track URLs to revoke later
    let worker = null;

    const els = {
        drop: document.getElementById('drop-zone'),
        input: document.getElementById('file-input'),
        progress: document.getElementById('progress-area'),
        bar: document.getElementById('progress-bar'),
        status: document.getElementById('status-text'),
        percent: document.getElementById('percent-text'),
        list: document.getElementById('chapter-list'),
        actionBar: document.getElementById('action-bar'),
        badge: document.getElementById('img-count-badge'),
        canvas: document.getElementById('merge-canvas'),
        settingsExtract: document.getElementById('settings-extract'),
        settingsMerge: document.getElementById('settings-merge'),
        downloadBtn: document.getElementById('download-btn'),
        modal: document.getElementById('img-modal'),
        modalImg: document.getElementById('modal-img')
    };

    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');

    function init() {
        // Init Worker
        const blob = new Blob([document.getElementById('worker-code').textContent], {type: 'text/javascript'});
        worker = new Worker(URL.createObjectURL(blob));
        worker.onmessage = handleWorkerMsg;
        
        // Restore Settings
        const saved = JSON.parse(localStorage.getItem('manga-tool-cfg') || '{}');
        if(saved.minSize) document.getElementById('size-filter').value = saved.minSize;
        if(saved.noGifs !== undefined) document.getElementById('no-gifs').checked = saved.noGifs;
        if(saved.reverse !== undefined) document.getElementById('reverse-sort').checked = saved.reverse;
        if(saved.rtl !== undefined) document.getElementById('rtl-mode').checked = saved.rtl;
        if(saved.theme) document.documentElement.setAttribute('data-theme', saved.theme);
    }

    window.saveConfig = function() {
        const cfg = {
            minSize: document.getElementById('size-filter').value,
            noGifs: document.getElementById('no-gifs').checked,
            reverse: document.getElementById('reverse-sort').checked,
            rtl: document.getElementById('rtl-mode').checked,
            theme: document.documentElement.getAttribute('data-theme')
        };
        localStorage.setItem('manga-tool-cfg', JSON.stringify(cfg));
        document.getElementById('size-val').innerText = cfg.minSize + " KB";
    };

    // --- FILES ---
    els.drop.onclick = () => els.input.click();
    els.input.onchange = () => { if(els.input.files.length) handleFiles(els.input.files); };

    async function handleFiles(files) {
        els.drop.style.display = 'none';
        els.progress.style.display = 'block';
        
        const mhtmlContents = [];
        const mhtmlNames = [];
        const looseImages = [];
        
        // Read files
        for(let i=0; i<files.length; i++) {
            els.status.innerText = `Reading ${files[i].name}...`;
            try {
                const name = files[i].name.toLowerCase();
                if (name.endsWith('.mhtml') || name.endsWith('.mht')) {
                    const text = await files[i].text();
                    mhtmlContents.push(text);
                    mhtmlNames.push(files[i].name);
                } 
                else if (name.match(/\.(jpg|jpeg|png|webp)$/)) {
                    const buf = await files[i].arrayBuffer();
                    looseImages.push({ name: files[i].name, data: new Uint8Array(buf), ext: name.split('.').pop() });
                }
            } catch (err) {}
        }

        if (looseImages.length > 0) {
            rawGroups.push({ groupName: "Loose Images", images: looseImages });
        }

        if (mhtmlContents.length > 0) {
            const config = {
                minSizeKB: parseInt(document.getElementById('size-filter').value),
                reverse: document.getElementById('reverse-sort').checked,
                excludeGifs: document.getElementById('no-gifs').checked
            };
            worker.postMessage({ type: 'extract', contents: mhtmlContents, filenames: mhtmlNames, config });
        } else if (looseImages.length > 0) {
            finishProcessing();
        }
    }

    function handleWorkerMsg(e) {
        const { type, text, percent, groups, blob, filename } = e.data;
        if(type === 'status') {
            els.status.innerText = text;
            els.bar.style.width = percent + "%";
            els.percent.innerText = Math.round(percent) + "%";
        }
        else if (type === 'extractDone') {
            rawGroups = [...rawGroups, ...groups];
            finishProcessing();
        }
        else if (type === 'zipDone') {
            downloadBlob(blob, filename);
            els.downloadBtn.innerText = "Download All";
            els.downloadBtn.disabled = false;
            els.status.innerText = "Complete";
            els.bar.style.width = "100%";
        }
    }

    function finishProcessing() {
        els.progress.style.display = 'none';
        els.actionBar.style.display = 'flex';
        els.badge.style.display = 'inline-block';
        els.badge.innerText = `${rawGroups.length} Chapters`;
        clearAndRender();
    }

    // --- RENDER LOGIC (LAZY) ---
    function clearAndRender() {
        els.list.innerHTML = '';
        rawGroups.forEach((group, idx) => {
            const item = document.createElement('div');
            item.className = 'chapter-item';
            
            // Header
            const head = document.createElement('div');
            head.className = 'chapter-head';
            head.innerHTML = `<span>${group.groupName}</span> <span style="font-size:0.8em; color:var(--text-sub)">${group.images.length} images</span>`;
            
            // Body (Hidden initially)
            const body = document.createElement('div');
            body.className = 'chapter-body';
            body.id = `chap-body-${idx}`;
            
            head.onclick = () => toggleChapter(idx, body, group);
            
            item.appendChild(head);
            item.appendChild(body);
            els.list.appendChild(item);
        });
    }

    async function toggleChapter(idx, container, group) {
        const isExpanded = container.classList.contains('expanded');
        
        if (isExpanded) {
            container.classList.remove('expanded');
            container.innerHTML = ''; // Clear DOM to save memory
        } else {
            container.classList.add('expanded');
            container.innerHTML = '<div style="padding:10px; text-align:center">Generating previews...</div>';
            
            // Slight delay to allow UI to update
            setTimeout(async () => {
                const grid = document.createElement('div');
                grid.className = currentMode === 'extract' ? 'gallery-grid' : 'gallery-grid merge-mode';
                
                // Show ALL images (scrollable inside the box) but generated on demand
                if (currentMode === 'extract') {
                    for(let img of group.images) {
                        const blob = new Blob([img.data], {type: 'image/'+img.ext});
                        const url = URL.createObjectURL(blob);
                        activeUrls.push(url); // Track for cleanup on reset
                        addToGrid(grid, url, false);
                    }
                } else {
                    // Merge logic
                    const ctx = els.canvas.getContext('2d');
                    const isRTL = document.getElementById('rtl-mode').checked;
                    for(let i=0; i<group.images.length; i+=2) {
                        const img1 = group.images[i];
                        const img2 = group.images[i+1];
                        
                        let blob;
                        if(!img2) {
                            blob = new Blob([img1.data]);
                        } else {
                            // Merge
                            const b1 = await createImageBitmap(new Blob([img1.data]));
                            const b2 = await createImageBitmap(new Blob([img2.data]));
                            els.canvas.width = b1.width + b2.width;
                            els.canvas.height = Math.max(b1.height, b2.height);
                            ctx.fillStyle="#fff"; ctx.fillRect(0,0,els.canvas.width,els.canvas.height);
                            if(isRTL) { ctx.drawImage(b2,0,0); ctx.drawImage(b1,b2.width,0); }
                            else { ctx.drawImage(b1,0,0); ctx.drawImage(b2,b1.width,0); }
                            blob = await new Promise(r=>els.canvas.toBlob(r, 'image/jpeg', 0.9));
                        }
                        const url = URL.createObjectURL(blob);
                        activeUrls.push(url);
                        addToGrid(grid, url, true);
                    }
                }
                container.innerHTML = '';
                container.appendChild(grid);
            }, 10);
        }
    }

    function addToGrid(grid, url, isMerge) {
        const div = document.createElement('div');
        div.className = `gallery-item ${isMerge?'merge-item':''}`;
        div.innerHTML = `<img src="${url}" loading="lazy">`;
        div.onclick = () => {
            els.modalImg.src = url;
            els.modal.style.display = 'flex';
        };
        grid.appendChild(div);
    }

    // --- ACTIONS ---
    window.setMode = (mode) => {
        currentMode = mode;
        document.querySelectorAll('.mode-tab').forEach(b => b.classList.remove('active'));
        document.getElementById(`tab-${mode}`).classList.add('active');
        if(mode === 'extract') {
            els.settingsExtract.classList.remove('hidden');
            els.settingsMerge.classList.add('hidden');
        } else {
            els.settingsExtract.classList.add('hidden');
            els.settingsMerge.classList.remove('hidden');
        }
        // Collapses all open chapters to force re-render with new mode
        clearAndRender();
    };

    window.shiftImages = async function() {
        if(rawGroups.length > 0) {
             const whitePixel = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
             const res = await fetch("data:image/png;base64," + whitePixel);
             const u8 = new Uint8Array(await res.arrayBuffer());
             rawGroups[0].images.unshift({ name: "0000.png", data: u8, ext: "png" });
             clearAndRender();
        }
    }

    els.downloadBtn.onclick = () => {
        if(!rawGroups.length) return;
        els.downloadBtn.disabled = true;
        els.downloadBtn.innerText = "Zipping...";
        els.progress.style.display = 'block';
        worker.postMessage({ type: 'zip', groups: rawGroups });
    };

    document.getElementById('reset-btn').onclick = () => {
        activeUrls.forEach(u => URL.revokeObjectURL(u)); // Cleanup memory
        location.reload();
    };

    document.getElementById('theme-toggle').onclick = () => {
        const html = document.documentElement;
        const newT = html.getAttribute('data-theme') === 'light' ? 'dark' : 'light';
        html.setAttribute('data-theme', newT);
        saveConfig();
    }

    function downloadBlob(blob, name) {
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = name;
        a.click();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    init();
</script>
</body>
</html>
